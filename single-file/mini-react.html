<!DOCTYPE html>
<html>
<head>
  <title>Mini React</title>
</head>
<body>
  <div id="root"></div>

  <script>
    /**
     * 创建虚拟DOM元素
     * @param {string|Function} type - 元素类型，可以是HTML标签名或函数组件
     * @param {object} props - 元素属性
     * @param {...any} children - 子元素
     * @returns {object} 虚拟DOM对象
     */
    function createElement(type, props, ...children) {
      return {
        type,
        props: {
          ...props,
          children: children.map(child =>
            typeof child === "object" ? child : createTextElement(child)
          ),
        },
      };
    }

    /**
     * 创建文本虚拟DOM元素
     * @param {string} text - 文本内容
     * @returns {object} 文本虚拟DOM对象
     */
    function createTextElement(text) {
      return {
        type: "TEXT_ELEMENT",
        props: {
          nodeValue: text,
          children: [],
        },
      };
    }

    /**
     * 将虚拟DOM渲染到真实DOM中
     * @param {object} element - 虚拟DOM元素
     * @param {HTMLElement} container - 容器元素
     */
    function render(element, container) {
      // 处理函数组件
      if (typeof element.type === "function") {
        const childElement = element.type(element.props);
        return render(childElement, container);
      }

      const dom =
        element.type == "TEXT_ELEMENT"
          ? document.createTextNode("")
          : document.createElement(element.type);

      const isProperty = key => key !== "children";
      const isEvent = key => key.startsWith("on");
      
      // 设置属性
      Object.keys(element.props)
        .filter(isProperty)
        .forEach(name => {
          dom[name] = element.props[name];
        });

      // 添加事件监听
      Object.keys(element.props)
        .filter(isEvent)
        .forEach(name => {
          const eventType = name.toLowerCase().substring(2);
          console.log(`Adding event listener for ${eventType}`);
          dom.addEventListener(eventType, element.props[name]);
        });

      element.props.children.forEach(child =>
        render(child, dom)
      );

      container.appendChild(dom);
    }

    // 状态管理
    let hookIndex = 0; // 当前hook的索引
    let hooks = []; // 存储所有hook状态的数组
    
    /**
     * 实现useState hook
     * @param {any} initial - 初始状态值
     * @returns {[any, Function]} 返回当前状态和更新状态的函数
     */
    function useState(initial) {
      const currentIndex = hookIndex++;
      hooks[currentIndex] = hooks[currentIndex] || initial;
      
      function setState(newState) {
        hooks[currentIndex] = newState;
        scheduleRender();
      }
      
      return [hooks[currentIndex], setState];
    }

    let isRendering = false; // 防止重复渲染的标志
    
    /**
     * 调度渲染，使用requestAnimationFrame优化性能
     */
    function scheduleRender() {
      if (!isRendering) {
        isRendering = true;
        requestAnimationFrame(() => {
          document.getElementById("root").innerHTML = "";
          hookIndex = 0;
          render(createElement(App), document.getElementById("root"));
          isRendering = false;
        });
      }
    }

    // 初始渲染
    scheduleRender();

    /**
     * 计数器组件示例
     * 展示如何使用useState hook管理状态
     */
    function Counter() {
      const [count, setCount] = useState(0);

      return (
        createElement("div", null,
          createElement("h1", null, "Count: ", count),
          createElement("button", { 
            onClick: () => setCount(count + 1) 
          }, "+"),
          createElement("button", { 
            onClick: () => setCount(count - 1) 
          }, "-")
        )
      );
    }

    /**
     * 根组件
     * 渲染Counter组件
     */
    function App() {
      return createElement(Counter);
    }

    // 渲染应用
    render(createElement(App), document.getElementById("root"));
  </script>
</body>
</html>